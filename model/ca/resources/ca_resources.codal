/**
 * Codasip s.r.o.
 *
 * CONFIDENTIAL
 *
 * Copyright 2022 Codasip s.r.o.
 *
 * All Rights Reserved.
 *
 * NOTICE: All information contained in this file, is and shall remain the property of
 * Codasip s.r.o. and its suppliers, if any.
 *
 * The intellectual and technical concepts contained herein are confidential and proprietary to
 * Codasip s.r.o. and are protected by trade secret and copyright law.  In addition, elements of the
 * technical concepts may be patent pending.
 *
 * This file is part of the Codasip Studio product. No part of the Studio product, including this
 * file, may be use, copied, modified, or distributed except in accordance with the terms contained
 * in Codasip license agreement under which you obtained this file.
 *
 *  \file   ca_
 *  """""""""""""""""""""""""""""resources.codal
 *  \author Codasip
 *  \date   09.02.2022
 *  \brief  cycle accurate model
 */

#include "ca_defines.hcodal"
#include "config.hcodal"

#define BOOLEAN_BIT     1    // Boolean control bit of width 1-bit
#define TWO_BIT         2       // Two bit wide control signal

pipeline pipe
{
    IFID, IDEX, EXMEM, MEMWB
};

// -------------------------------------------------------------------------------------------------
// Fetch stage
// -------------------------------------------------------------------------------------------------

// Current Program Counter (PC) address of instruction fetch request
signal bit[ADDR_W] s_if_nextpc;

// IFID pipeline register
register bit[ADDR_W]        r_ifid_pc             { pipeline = pipe.IFID; };     // Program Counter

// -------------------------------------------------------------------------------------------------
// Decode stage
// -------------------------------------------------------------------------------------------------


// Instruction
signal bit[INSTR_W]         s_id_instr;                 // Instruction
signal bit[OPC_W]           s_id_opcode;                // Complete 17-bit opcode
signal bit[RF_XPR_W]        s_id_src1;                  // src1 register address
signal bit[RF_XPR_W]        s_id_src2;                  // src2 register address
signal bit[RF_XPR_W]        s_id_rd;                    // rd destination address
signal bit[WORD_W]          s_id_rf_src1;               // value of src1 from register file
signal bit[WORD_W]          s_id_rf_src2;               // value of src2 from regsiter file

// ALU Operation Control
signal bit[ALUOP_W]         s_id_aluop;                 // ALU opcode
signal bit[BOOLEAN_BIT]        s_id_halt;                  // Control bit to halt processor simulation

// Immediate operand generation resources
signal bit[IMM_GEN_SEL_W]   s_id_imm_gen_sel;           // select the type of immediate to pass to execute stage
signal bit[WORD_W]          s_id_imm_rtype;
signal bit[WORD_W]          s_id_imm_itype;
signal bit[WORD_W]          s_id_imm_stype;
signal bit[WORD_W]          s_id_imm_btype;
signal bit[WORD_W]          s_id_imm_utype;
signal bit[WORD_W]          s_id_imm_jtype;

// Singals/registers to preserve instruction durin a pipeline stall
signal bit[BOOLEAN_BIT]     s_id_icache_stall;
register bit[BOOLEAN_BIT]   r_id_icache_stall;
register bit[BOOLEAN_BIT]   r_id_flush_icache            {default = false;};   // used to flush current instruction being read
register bit[BOOLEAN_BIT]   r_id_buffer_full             {default = false;};   // indicate whether previous cycle stalled
register bit[INSTR_W]       r_id_instr_preserved;       // Preserve last instruction to reconstruct inst. in stall
register bit[WORD_W]        r_id_pc_preserved;          // Preserve the PC address of instruction safed in buffer

// Signals generated by the Instruction Decoder
signal bit[BOOLEAN_BIT]        s_id_regwrite;              // Write to rd (write register) if true
signal bit[ALU_SRC1_SEL_W]  s_id_alusrc1;               // src1 operand mux select line
signal bit[ALU_SRC2_SEL_W]  s_id_alusrc2;               // src2 operand mux select line
signal bit[MEM_OPCODE_W]    s_id_mem_ops;               // Memory opcode
signal bit[BOOLEAN_BIT]        s_id_memread;               // Memory load operation if true
signal bit[BOOLEAN_BIT]        s_id_branch_inst;           // bit used to notify an instruction is a branch
signal bit[BOOLEAN_BIT]        s_id_jump_inst;             // bit used to notify a jump instruction

// Associated signals for data hazard detection and forwarding
signal bit[BOOLEAN_BIT]        s_id_src1_ex_hz;            // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src2_ex_hz;            // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src1_mem_hz;           // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src2_mem_hz;           // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src1_wb_hz;            // Hazard detected if true
signal bit[BOOLEAN_BIT]        s_id_src2_wb_hz;            // Hazard detected if true

// IDEX pipeline register
register bit[ADDR_W]    r_idex_pc                  { pipeline = pipe.IDEX; };    // Program Counter
register bit[ALUOP_W]   r_idex_aluop               { pipeline = pipe.IDEX; };    // ALU opcode
register bit[RF_XPR_W]  r_idex_rd                  { pipeline = pipe.IDEX; };    // rd (write) register number
register bit[BOOLEAN_BIT]  r_idex_regwrite            { pipeline = pipe.IDEX; };    // Does the current instruction wrt to RF
register bit[ALU_SRC1_SEL_W] r_idex_src1_sl        { pipeline = pipe.IDEX; };    // ALU src1 select lines for mux
register bit[ALU_SRC2_SEL_W] r_idex_src2_sl        { pipeline = pipe.IDEX; };    // ALU src2 select lines for mux
register bit[WORD_W]    r_idex_rf_src1             { pipeline = pipe.IDEX; };    // register file output for src1
register bit[WORD_W]    r_idex_rf_src2             { pipeline = pipe.IDEX; };    // register file output for src2
register bit[WORD_W]    r_idex_src2_imm            { pipeline = pipe.IDEX; };    // immediate value for src2
register bit[BOOLEAN_BIT]  r_idex_branch_inst         { pipeline = pipe.IDEX; };    // take branch in ME stage if branch
register bit[BOOLEAN_BIT]  r_idex_jump_inst           { pipeline = pipe.IDEX; };    // unconditional jump control signal
register bit[JUMP_DF_MUX_W] r_idex_jump_df_mux     { pipeline = pipe.IDEX; };    // jump address calculation source
register bit[BOOLEAN_BIT]  r_idex_memread             { pipeline = pipe.IDEX; };    // load operaton if true
register bit[MEM_OPCODE_W] r_idex_mem_ops          { pipeline = pipe.IDEX; };    // memory opcode

register bit[BOOLEAN_BIT]  r_idex_src2_ex_hz       { pipeline = pipe.IDEX; };    // Passing src2 EX stage hazard detect to EX stage for Store rs2 forwarding
register bit[BOOLEAN_BIT]  r_idex_src2_mem_hz      { pipeline = pipe.IDEX; };    // Passing src2 MEM stage hazard detect to EX stage for Store rs2 forwarding

register bit[BOOLEAN_BIT]  r_idex_halt                { pipeline = pipe.IDEX; };    // Halt control bit


// -------------------------------------------------------------------------------------------------
// Execute stage
// -------------------------------------------------------------------------------------------------

// ALU signals
signal bit[WORD_W]      s_src1_operand;         // src1 operand into ALU
signal bit[WORD_W]      s_src2_operand;         // src2 operand into ALU
signal bit[WORD_W]      s_ex_alu_result;        // result of ALU operation
signal bit[BOOLEAN_BIT]    s_ex_branch_true;       // set if branch taken or jump

// Branch implementation signals
signal bit[ADDR_W]      s_ex_branch_addr;       // Address if branch and for jumps

// Memory operation signals
signal bit[WORD_W]      s_ex_mem_encodeddata;   // Encoded data for memory access
signal bit[2]           s_ex_mem_size;          // Memory bus access size

// EXMEM pipeline register
register bit[WORD_W]   r_exmem_alu_result          { pipeline = pipe.EXMEM; };    // Result from ALU
register bit[RF_XPR_W] r_exmem_rd                  { pipeline = pipe.EXMEM; };    // rd / write register
register bit[BOOLEAN_BIT] r_exmem_regwrite            { pipeline = pipe.EXMEM; };    // Does the current instruction wrt to RF
register bit[BOOLEAN_BIT] r_exmem_branch_inst         { pipeline = pipe.EXMEM; };    // take branch in ME stage if branch
register bit[BOOLEAN_BIT] r_exmem_branch_true         { pipeline = pipe.EXMEM; };    // Forward branch taken to ME stage
register bit[ADDR_W]   r_exmem_branch_addr         { pipeline = pipe.EXMEM; };    // branch address if taken
register bit[BOOLEAN_BIT] r_exmem_jump_inst           { pipeline = pipe.EXMEM; };    // unconditional jump control signal
//register bit[BOOLEAN_BIT] r_exmem_memwrite            { pipeline = pipe.EXMEM; };    // store operaton if true
register bit[BOOLEAN_BIT] r_exmem_memread             { pipeline = pipe.EXMEM; };    // load operaton if true
register bit[MEM_OPCODE_W] r_exmem_mem_ops         { pipeline = pipe.EXMEM; };    // memory opcode
register bit[WORD_W]   r_exmem_mem_encodeddata     { pipeline = pipe.EXMEM; };    // encoded memory access data
register bit[2]        r_exmem_mem_size            { pipeline = pipe.EXMEM; };    // Memory bus access size


// -------------------------------------------------------------------------------------------------
// Memory stage
// -------------------------------------------------------------------------------------------------

// Branch control signals
signal bit[BOOLEAN_BIT]   s_me_take_branch;                                    // take branch if branch inst & branch true
signal bit[WORD_W]     s_me_mem_result;                                     // read result from load
signal bit[BOOLEAN_BIT]   s_me_mem_busy;                                       // Memory bus is busy.

// MEMWB pipeline register
register bit[WORD_W]   r_memwb_data_result         { pipeline = pipe.MEMWB; };    // Result from ALU
register bit[RF_XPR_W] r_memwb_rd                  { pipeline = pipe.MEMWB; };    // rd / write register
register bit[BOOLEAN_BIT] r_memwb_regwrite            { pipeline = pipe.MEMWB; };    // Does the current instruction wrt to RF

// -------------------------------------------------------------------------------------------------
// Writeback stage
// -------------------------------------------------------------------------------------------------




// -------------------------------------------------------------------------------------------------
// Pipeline control
// -------------------------------------------------------------------------------------------------

signal   bit[BOOLEAN_BIT] s_id_stall;
signal   bit[BOOLEAN_BIT] s_id_clear;
register bit[BOOLEAN_BIT] r_id_clear {default = true;};
signal   bit[BOOLEAN_BIT] s_wb_stall;

register bit[BOOLEAN_BIT] r_id_stalled             {default = false;};          // indicate whether previous cycle stalled

// -------------------------------------------------------------------------------------------------
// SYSCALL support for simulation
// -------------------------------------------------------------------------------------------------
signal bit [BOOLEAN_BIT]   s_syscall_pending;
signal bit [BOOLEAN_BIT]   s_syscall_stall;
register bit [TWO_BIT]  r_syscall_delay         {default = 0;};

